import json
import os
import sys
import argparse

from sqlalchemy import create_engine, MetaData, select, literal, text, inspect
from sqlalchemy.schema import Table

# try to import project default URL if available
try:
    from backend.core.dependencies import SQLALCHEMY_DATABASE_URL
except Exception:
    SQLALCHEMY_DATABASE_URL = None

DEFAULT_URL = os.getenv("DATABASE_URL") or SQLALCHEMY_DATABASE_URL
DEFAULT_OUT = "./static/field_dump.sql"
DEFAULT_TABLE = "fields"


def quote_name(preparer, name):
    return preparer.quote(name)


def table_qualified_name(preparer, table):
    if getattr(table, "schema", None):
        return f"{quote_name(preparer, table.schema)}.{quote_name(preparer, table.name)}"
    return quote_name(preparer, table.name)


def dump_fields(url, out_path, table_name=DEFAULT_TABLE):
    if not url:
        raise SystemExit("No database URL provided. Set DATABASE_URL env or pass --url.")

    engine = create_engine(
        url, pool_pre_ping=True,
        connect_args={"options": "-c client_encoding=utf8"} if "postgres" in url else {},
    )
    metadata = MetaData()
    metadata.reflect(bind=engine, only=[table_name])

    if table_name not in metadata.tables:
        raise SystemExit(f"Table `{table_name}` not found in database.")

    table = metadata.tables[table_name]
    preparer = engine.dialect.identifier_preparer
    qualified = table_qualified_name(preparer, table)

    # build column list excluding id (case-insensitive)
    cols = [c for c in table.columns if c.name.lower() != "id"]
    col_names = [quote_name(preparer, c.name) for c in cols]

    with engine.connect() as conn, open(out_path, "w", encoding="utf-8") as f:
        # optional: write search_path for postgres
        try:
            if engine.dialect.name == "postgresql":
                sp = conn.execute(text("SHOW search_path")).scalar()
                f.write(f"-- search_path: {sp}\n\n")
        except Exception:
            pass

        f.write(f"-- Dump of table {qualified} (without id). Generated by field_dump.py\n\n")

        # select ordered by category, id
        sel = select(table).order_by(table.c.category, table.c.id)
        result = conn.execute(sel)
        # use mappings() to get dict-like rows so we can reference columns by name
        rows = result.mappings().all()

        for row in rows:
            vals = []
            # iterate over actual columns order but skip id
            for c in cols:
                # access by column name from mapping
                v = row.get(c.name)
                if v is None:
                    vals.append("NULL")
                    continue

                # bytes -> decode
                if isinstance(v, (bytes, bytearray)):
                    try:
                        v = v.decode('utf-8')
                    except Exception:
                        v = bytes(v).hex()

                # try SQLAlchemy literal compilation for safe formatting
                try:
                    lit = literal(v)
                    compiled = lit.compile(dialect=engine.dialect, compile_kwargs={"literal_binds": True})
                    vals.append(str(compiled))
                    continue
                except Exception:
                    pass

                # fallback to JSON serialization then escape single quotes
                try:
                    # For non-serializable objects, str() will be used
                    sval = json.dumps(v, ensure_ascii=False)
                except Exception:
                    sval = str(v)
                # json.dumps produces quoted string for primitives; if it's a JSON string like '"x"', strip outer quotes
                if isinstance(sval, str) and len(sval) >= 2 and sval[0] == '"' and sval[-1] == '"':
                    sval_inner = sval[1:-1]
                    escaped = sval_inner.replace("'", "''")
                    vals.append(f"'{escaped}'")
                else:
                    escaped = sval.replace("'", "''")
                    vals.append(f"'{escaped}'")

            if col_names:
                f.write(f"INSERT INTO {qualified} ({', '.join(col_names)}) VALUES ({', '.join(vals)});\n")

        f.write("\n")
    print(f"dumped to {out_path}")


def parse_args(argv):
    p = argparse.ArgumentParser(description="Dump `fields` as INSERTs without id, ordered by (category, id).")
    p.add_argument("--url", help="Database URL (overrides env)", default=None)
    p.add_argument("--out", help="Output SQL file", default=DEFAULT_OUT)
    p.add_argument("--table", help="Table name (default fields)", default=DEFAULT_TABLE)
    args = p.parse_args(argv)
    url = args.url or os.getenv("DATABASE_URL") or DEFAULT_URL
    return url, args.out, args.table


if __name__ == "__main__":
    url, out, table = parse_args(sys.argv[1:])
    dump_fields(url, out, table)
